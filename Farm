-- ===================================================================
-- SCRIPT FINAL V15 (COMPLETO)
-- ===================================================================

-- =================== CONFIGURAÇÕES ===================
local ALCANCE_COLETA_PASSIVA = 20
local NOME_DO_NPC_VENDEDOR = "Merchant"
local TELEPORT_DIST_THRESHOLD = 5 -- só teleporta se estiver a mais de 5 studs do item

local priority = {
    ["Perfect Crystal"] = 6000, ["Green Jewel"] = 3100, ["Red Jewel"] = 400,
    ["Gold Crown"] = 200, ["Ancient Coin"] = 120, ["Gold Jar"] = 90,
    ["Golden Ring"] = 54, ["Gold Goblet"] = 48, ["Silver Jar"] = 42,
    ["Silver Goblet"] = 32, ["Silver Ring"] = 32, ["Bronze Jar"] = 20,
    ["Copper Goblet"] = 16, ["Rusty Goblet"] = 12
}
-- ===================================================

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local workspaceItems = workspace
local isTeleporting = false
local isCollecting = false

local camera = workspace.CurrentCamera
local cameraWasCustom = camera.CameraType

-- =================== CRIAÇÃO DA UI ===================
local playerGui = player:WaitForChild("PlayerGui")
local screenGui = playerGui:FindFirstChild("AutoFarmGUI") or Instance.new("ScreenGui", playerGui)
screenGui.Name = "AutoFarmGUI"; screenGui.ResetOnSpawn = false
local frame = screenGui:FindFirstChild("MainFrame") or Instance.new("Frame", screenGui)
frame.Name = "MainFrame"; frame.Size = UDim2.new(0, 140, 0, 180); frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40); frame.BorderSizePixel = 0; frame.Active = true; frame.Draggable = true; frame.Position = UDim2.new(0, 10, 0, 10)

-- BOTÕES UI
local function criarBotao(nome, y, cor)
    local b = frame:FindFirstChild(nome) or Instance.new("TextButton", frame)
    b.Name = nome; b.Size = UDim2.new(0, 120, 0, 20); b.Position = UDim2.new(0, 10, 0, y)
    b.BackgroundColor3 = cor; b.TextColor3 = Color3.new(1,1,1); b.Font = Enum.Font.SourceSansBold; b.TextSize = 14
    b.Text = nome
    return b
end

local sellButton = criarBotao("Teleportar Venda", 135, Color3.fromRGB(255,190,0))
local hopButton = criarBotao("Trocar Servidor", 160, Color3.fromRGB(0,120,255))

-- TOGGLES
local function criarToggle(nome, y)
    local toggle = frame:FindFirstChild(nome.."Toggle") or Instance.new("Frame", frame)
    toggle.Name = nome.."Toggle"; toggle.Size = UDim2.new(0, 120, 0, 40); toggle.Position = UDim2.new(0,10,0,y)
    toggle.BackgroundColor3 = Color3.fromRGB(70,70,70); toggle.BorderSizePixel = 0
    local knob = toggle:FindFirstChild("Knob") or Instance.new("Frame", toggle)
    knob.Name = "Knob"; knob.Size = UDim2.new(0,40,0,40); knob.Position = UDim2.new(0,0,0,0); knob.BackgroundColor3 = Color3.fromRGB(200,50,50); knob.BorderSizePixel = 0
    return toggle, knob
end

local teleportToggle, teleportKnob = criarToggle("Teleport", 25)
local collectToggle, collectKnob = criarToggle("Collect", 90)

-- Lógica dos Toggles
teleportToggle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isTeleporting = not isTeleporting
        local goal = isTeleporting and {Position = UDim2.new(0,80,0,0), BackgroundColor3 = Color3.fromRGB(50,200,50)}
        or {Position = UDim2.new(0,0,0,0), BackgroundColor3 = Color3.fromRGB(200,50,50)}
        TweenService:Create(teleportKnob, TweenInfo.new(0.2), goal):Play()
        -- Resetar câmera ao desligar
        if not isTeleporting then
            camera.CameraType = Enum.CameraType.Custom
        end
    end
end)

collectToggle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isCollecting = not isCollecting
        local goal = isCollecting and {Position = UDim2.new(0,80,0,0), BackgroundColor3 = Color3.fromRGB(50,200,50)}
        or {Position = UDim2.new(0,0,0,0), BackgroundColor3 = Color3.fromRGB(200,50,50)}
        TweenService:Create(collectKnob, TweenInfo.new(0.2), goal):Play()
    end
end)

-- =================== FUNÇÃO DE TELEPORTE PARA VENDA ===================
sellButton.MouseButton1Click:Connect(function()
    local npcVendedor = workspace:FindFirstChild(NOME_DO_NPC_VENDEDOR, true)
    if not npcVendedor then warn("NPC '"..NOME_DO_NPC_VENDEDOR.."' não encontrado.") return end
    hrp.CFrame = npcVendedor:GetPrimaryPartCFrame() * CFrame.new(0,0,5)
    print("Teleportando para "..NOME_DO_NPC_VENDEDOR..". Clique para vender.")
end)

-- =================== FUNÇÃO DE SERVER HOP ===================
hopButton.MouseButton1Click:Connect(function()
    print("Iniciando troca de servidor...")
    pcall(TeleportService.Teleport, TeleportService, game.PlaceId)
end)

-- =================== FUNÇÕES AUXILIARES ===================
local function getItemFromPrompt(prompt)
    local obj = prompt.Parent
    for i=1,5 do
        if obj == nil then break end
        if priority[obj.Name] then return obj end
        obj = obj.Parent
    end
    return nil
end

local function collectPrompt(prompt)
    local ok, item = pcall(getItemFromPrompt, prompt)
    if ok and item then
        pcall(function()
            prompt:InputHoldBegin()
            task.wait(0.2)
            prompt:InputHoldEnd()
        end)
    end
end

-- =================== LÓGICA DE COLETA ===================
-- ============ DEBUG E HELPERS ============
local DEBUG = true
local function dbg(...)
    if DEBUG then
        print("[AF-Collect]", ...)
    end
end
local function warnf(...)
    warn("[AF-Collect][ERRO]", ...)
end

-- Verifica se um ProximityPrompt é "coletável" pelo seu critério de Adornee
local function isCollectablePrompt(prompt)
    if not prompt or not prompt:IsA("ProximityPrompt") then
        return false, "Prompt inexistente ou não é ProximityPrompt"
    end

    local ad = prompt.Adornee
    if not ad then
        -- fallback: tenta achar um BasePart no parent para usar como referência
        ad = prompt.Parent and prompt.Parent:FindFirstChildWhichIsA("BasePart")
    end
    if not ad then
        return false, "Sem Adornee e sem BasePart no parent"
    end

    if ad:IsA("Part") or ad:IsA("MeshPart") then
        return true
    end
    if ad.Name == "Main" then
        return true
    end
    return false, ("Adornee inválido: %s (%s)"):format(ad.Name, ad.ClassName)
end

-- Retorna a posição de referência do prompt (Adornee ou um BasePart próximo)
local function getPromptPosition(prompt)
    local ad = prompt.Adornee
    if ad and ad:IsA("BasePart") then
        return ad.Position
    end
    local bp = prompt.Parent and prompt.Parent:FindFirstChildWhichIsA("BasePart")
    if bp then return bp.Position end
    return nil
end

-- Coleta segura com logs
local function tryCollectPrompt(prompt)
    local okValid, reason = isCollectablePrompt(prompt)
    if not okValid then
        dbg("Rejeitado:", reason)
        return false, reason
    end

    if not prompt.Enabled then
        return false, "Prompt.Enabled = false"
    end

    local pos = getPromptPosition(prompt)
    if not pos then
        return false, "Sem posição (Adornee/BasePart) para medir distância"
    end

    local dist = (hrp.Position - pos).Magnitude
    local maxDist = prompt.MaxActivationDistance or 0
    if maxDist <= 0 then
        return false, "MaxActivationDistance <= 0"
    end
    if dist > maxDist then
        return false, ("Longe demais: dist=%.1f > Max=%.1f"):format(dist, maxDist)
    end

    -- Efetivamente “apertar” o prompt
    -- Se for hold, seguramos rapidinho; se não for, um tap já serve.
    local hold = prompt.HoldDuration or 0
    dbg(("Coletando '%s' (dist=%.1f, hold=%.2f)"):format(prompt.Name, dist, hold))
    pcall(function()
        prompt:InputHoldBegin()
        if hold > 0 then
            task.wait(math.max(hold, 0.15))
        else
            task.wait(0.15)
        end
        prompt:InputHoldEnd()
    end)
    return true
end

-- Busca o MELHOR item dentro do alcance e o respectivo prompt válido
local function findBestCollectablePrompt()
    local bestItem, bestScore, bestPrompt = nil, -1, nil

    for _, item in ipairs(workspaceItems:GetChildren()) do
        local val = priority[item.Name]
        if val then
            -- prioriza por valor (tabela priority) e proximidade
            local part = item:FindFirstChild("Part") or item:FindFirstChild("Main") or item:FindFirstChildWhichIsA("MeshPart")
            if part then
                local d = (hrp.Position - part.Position).Magnitude
                if d <= ALCANCE_COLETA_PASSIVA then
                    -- pegue o prompt mais próximo dentro do item
                    local prompt = item:FindFirstChildWhichIsA("ProximityPrompt", true)
                    if prompt then
                        local ok, _ = isCollectablePrompt(prompt)
                        if ok then
                            -- score simples: valor prioritário / (1 + distância)
                            local score = val / (1 + d)
                            if score > bestScore then
                                bestScore = score
                                bestItem = item
                                bestPrompt = prompt
                            end
                        else
                            -- log leve: prompt existe mas não é válido (adornee errado)
                            if DEBUG then
                                local ad = prompt.Adornee
                                dbg(("Descartado %s: Adornee=%s(%s)")
                                    :format(item.Name, ad and ad.Name or "nil", ad and ad.ClassName or "nil"))
                            end
                        end
                    else
                        if DEBUG then dbg("Sem ProximityPrompt em", item:GetFullName()) end
                    end
                end
            end
        end
    end

    return bestItem, bestPrompt
end

-- =================== TELEPORTE REATIVO + CAMERA SPECTATOR ===================
task.spawn(function()
    while true do
        task.wait(0.1)
        if isTeleporting then
            local bestItem, bestValue = nil, -1
            for _, item in pairs(workspaceItems:GetChildren()) do
                if priority[item.Name] and priority[item.Name] > bestValue then
                    bestValue = priority[item.Name]
                    bestItem = item
                end
            end
            if bestItem then
                local part = bestItem:FindFirstChild("Part") or bestItem:FindFirstChild("Main") or bestItem:FindFirstChildWhichIsA("MeshPart")
                if part then
                    local distance = (hrp.Position - part.Position).Magnitude
                    if distance > TELEPORT_DIST_THRESHOLD then
                        hrp.CFrame = part.CFrame + Vector3.new(0,3,0)
                    end
                    -- câmera spectator
                    camera.CameraType = Enum.CameraType.Scriptable
                    camera.CFrame = CFrame.new(part.Position + Vector3.new(0,12,12), part.Position)
                end
            else
                camera.CameraType = Enum.CameraType.Custom
            end
        else
            camera.CameraType = Enum.CameraType.Custom
        end
    end
end)
